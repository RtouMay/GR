const canvas = document.getElementById('gameCanvas');const ctx = canvas.getContext('2d');const currentScoreDisplay = document.getElementById('currentScore');const highScoreDisplay = document.getElementById('highScore');const gameOverScreen = document.getElementById('gameOverScreen');const finalScoreDisplay = document.getElementById('finalScore');const restartButton = document.getElementById('restartButton');// متغیرهای بازیlet player;let obstacles = [];let clouds = [];let groundTiles = [];let score = 0;let highScore = parseInt(localStorage.getItem('dinoHighScore') || '0', 10);let gameSpeed = 4; // سرعت اولیه بازیlet gameOver = false;let frameId; // برای نگهداری شناسه requestAnimationFramelet lastObstacleTime = 0;let lastCloudTime = 0;// ثابت‌هاconst CANVAS_WIDTH = 800;const CANVAS_HEIGHT = 200;const GROUND_Y = CANVAS_HEIGHT - 20; // ارتفاع زمین// تنظیمات Player (دایناسور هندسی)const PLAYER_WIDTH = 30;const PLAYER_HEIGHT = 40;const PLAYER_START_X = 50;const PLAYER_COLOR = '#00e676'; // سبز روشن برای دایناسور// تنظیمات پرشconst JUMP_VELOCITY = -10;const GRAVITY = 0.5;// تنظیمات موانع (هندسی)const OBSTACLE_MIN_GAP = 300;const OBSTACLE_MAX_GAP = 500;const OBSTACLE_COLOR = '#ff1744'; // قرمز برای موانعconst OBSTACLE_TYPES = [    { type: 'cactus1', width: 20, height: 40 }, // کاکتوس کوچک    { type: 'cactus2', width: 40, height: 40 }, // کاکتوس بزرگ    { type: 'pterodactyl', width: 40, height: 25, yOffset: 40 } // پرنده];// تنظیمات ابرها (هندسی)const CLOUD_WIDTH = 60;const CLOUD_HEIGHT = 20;const CLOUD_COLOR = '#b0bec5'; // خاکستری روشن برای ابرهاconst CLOUD_MIN_GAP = 200;const CLOUD_MAX_GAP = 600;// صداها (اگر فایل mp3 رو قرار بدید، اینا کار میکنن، وگرنه خطایی رخ نمیده)const jumpSound = new Audio('assets/jump.mp3');const hitSound = new Audio('assets/hit.mp3');// Player classclass Player {    constructor() {        this.x = PLAYER_START_X;        this.y = GROUND_Y - PLAYER_HEIGHT;        this.width = PLAYER_WIDTH;        this.height = PLAYER_HEIGHT;        this.velocityY = 0;        this.jumps = 0;        this.maxJumps = 2;    }    draw() {        ctx.fillStyle = PLAYER_COLOR;        ctx.fillRect(this.x, this.y, this.width, this.height);        // یک چشم ساده برای دایناسور        ctx.fillStyle = 'black';        ctx.beginPath();        ctx.arc(this.x + this.width - 10, this.y + 10, 3, 0, Math.PI * 2);        ctx.fill();    }    update() {        this.y += this.velocityY;        this.velocityY += GRAVITY;        if (this.y >= GROUND_Y - this.height) {            this.y = GROUND_Y - this.height;            this.velocityY = 0;            this.jumps = 0;        }    }    jump() {        if (this.jumps < this.maxJumps) {            this.velocityY = JUMP_VELOCITY;            this.jumps++;            jumpSound.currentTime = 0;            jumpSound.play().catch(e => console.log("Jump sound play failed:", e));        }    }}// Obstacle classclass Obstacle {    constructor(type) {        const typeData = OBSTACLE_TYPES.find(t => t.type === type);        this.type = type;        this.width = typeData.width;        this.height = typeData.height;        this.x = CANVAS_WIDTH;        this.y = GROUND_Y - this.height;        if (typeData.yOffset) {            this.y -= typeData.yOffset; // برای تنظیم ارتفاع پرنده        }    }    draw() {        ctx.fillStyle = OBSTACLE_COLOR;        if (this.type.includes('cactus')) {            // کاکتوس‌ها رو با جزئیات بیشتر بکش            ctx.fillRect(this.x, this.y, this.width, this.height);            // شاخه‌های کاکتوس            ctx.fillRect(this.x - 5, this.y + this.height / 2, 10, 10);            ctx.fillRect(this.x + this.width - 5, this.y + this.height / 2, 10, 10);        } else if (this.type === 'pterodactyl') {            // پرنده رو با فرم ساده بکش            ctx.beginPath();            ctx.moveTo(this.x, this.y + this.height / 2);            ctx.lineTo(this.x + this.width, this.y);            ctx.lineTo(this.x + this.width, this.y + this.height);            ctx.fill();            ctx.closePath();        }    }    update() {        this.x -= gameSpeed;    }}// Cloud classclass Cloud {    constructor() {        this.x = CANVAS_WIDTH;        this.y = Math.random() * (CANVAS_HEIGHT / 2 - CLOUD_HEIGHT);        this.width = CLOUD_WIDTH;        this.height = CLOUD_HEIGHT;        this.speed = gameSpeed * (0.2 + Math.random() * 0.4);    }    draw() {        ctx.fillStyle = CLOUD_COLOR;        // رسم ابر به شکل چند دایره متصل        ctx.beginPath();        ctx.arc(this.x, this.y + this.height / 2, this.height / 2, 0, Math.PI * 2);        ctx.arc(this.x + this.width * 0.3, this.y + this.height * 0.3, this.height * 0.6, 0, Math.PI * 2);        ctx.arc(this.x + this.width * 0.7, this.y + this.height * 0.4, this.height * 0.7, 0, Math.PI * 2);        ctx.arc(this.x + this.width, this.y + this.height / 2, this.height / 2, 0, Math.PI * 2);        ctx.fill();        ctx.closePath();    }    update() {        this.x -= this.speed;    }}// Ground classclass Ground {    constructor(x) {        this.x = x;        this.y = GROUND_Y;        this.width = CANVAS_WIDTH * 2; // عرض زمین رو بیشتر می‌کنیم تا همیشه پوشش بده        this.height = CANVAS_HEIGHT - GROUND_Y;        this.color = '#555'; // رنگ زمین    }    draw() {        ctx.fillStyle = this.color;        ctx.fillRect(this.x, this.y, this.width, this.height);        // خطوط راهرو روی زمین        ctx.fillStyle = '#666';        for (let i = 0; i < this.width; i += 50) {            ctx.fillRect(this.x + i, this.y + 5, 20, 2);        }    }    update() {        this.x -= gameSpeed;        if (this.x + this.width < 0) {            this.x = this.x + this.width * 2; // تایل رو به انتهای مجموعه بفرست        }    }}// --- توابع اصلی بازی ---function initGame() {    canvas.width = CANVAS_WIDTH;    canvas.height = CANVAS_HEIGHT;    player = new Player();    obstacles = [];    clouds = [];    groundTiles = [];    score = 0;    gameSpeed = 4; // Reset game speed    gameOver = false;    currentScoreDisplay.textContent = score;    highScoreDisplay.textContent = highScore;    gameOverScreen.style.display = 'none';    // ایجاد تایل‌های زمین    groundTiles.push(new Ground(0));    groundTiles.push(new Ground(CANVAS_WIDTH * 2)); // تایل دوم بلافاصله بعد از اولی شروع میشه    if (frameId) {        cancelAnimationFrame(frameId);    }    gameLoop();}function generateObstacle() {    const currentTime = Date.now();    const lastObstacle = obstacles[obstacles.length - 1];    const timeSinceLastObstacle = currentTime - lastObstacleTime;    let requiredGap = Math.random() * (OBSTACLE_MAX_GAP - OBSTACLE_MIN_GAP) + OBSTACLE_MIN_GAP;    requiredGap = requiredGap / (gameSpeed / 4);    if (!lastObstacle || (CANVAS_WIDTH - lastObstacle.x > requiredGap && timeSinceLastObstacle > 1000 / (gameSpeed / 2))) {        const randomIndex = Math.floor(Math.random() * OBSTACLE_TYPES.length);        obstacles.push(new Obstacle(OBSTACLE_TYPES[randomIndex].type));        lastObstacleTime = currentTime;    }}function generateCloud() {    const currentTime = Date.now();    const lastCloud = clouds[clouds.length - 1];    const timeSinceLastCloud = currentTime - lastCloudTime;    const requiredGap = Math.random() * (CLOUD_MAX_GAP - CLOUD_MIN_GAP) + CLOUD_MIN_GAP;    if (!lastCloud || (CANVAS_WIDTH - lastCloud.x > requiredGap && timeSinceLastCloud > 5000 / (gameSpeed / 2))) {        clouds.push(new Cloud());        lastCloudTime = currentTime;    }}function updateGame() {    if (gameOver) return;    score++;    currentScoreDisplay.textContent = Math.floor(score / 10);    gameSpeed = 4 + Math.floor(score / 1000) * 0.5;    player.update();    groundTiles.forEach(tile => tile.update());    generateObstacle();    generateCloud();    obstacles.forEach((obstacle, index) => {        obstacle.update();        if (obstacle.x + obstacle.width < 0) {            obstacles.splice(index, 1);        }        // تشخیص برخورد (AABB collision detection)        if (            player.x < obstacle.x + obstacle.width &&            player.x + player.width > obstacle.x &&            player.y < obstacle.y + obstacle.height &&            player.y + player.height > obstacle.y        ) {            endGame();        }    });    clouds.forEach((cloud, index) => {        cloud.update();        if (cloud.x + cloud.width < 0) {            clouds.splice(index, 1);        }    });}function drawGame() {    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // پاک کردن بوم    clouds.forEach(cloud => cloud.draw());    groundTiles.forEach(tile => tile.draw());    player.draw();    obstacles.forEach(obstacle => obstacle.draw());}function gameLoop() {    updateGame();    drawGame();    if (!gameOver) {        frameId = requestAnimationFrame(gameLoop);    }}function endGame() {    gameOver = true;    hitSound.play().catch(e => console.log("Hit sound play failed:", e));    const finalScore = Math.floor(score / 10);    finalScoreDisplay.textContent = `امتیاز نهایی: ${finalScore}`;    if (finalScore > highScore) {        highScore = finalScore;        localStorage.setItem('dinoHighScore', highScore);        highScoreDisplay.textContent = highScore;    }    gameOverScreen.style.display = 'flex';    cancelAnimationFrame(frameId);}// مدیریت ورودی (کیبورد و لمس)document.addEventListener('keydown', (e) => {    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {        if (!gameOver) {            player.jump();        } else {            initGame();        }    }});canvas.addEventListener('touchstart', (e) => {    e.preventDefault();    if (!gameOver) {        player.jump();    } else {        initGame();    }});restartButton.addEventListener('click', () => {    initGame();});// شروع بازیinitGame();